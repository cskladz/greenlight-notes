{"title":"Pure Functions","message":"same input(s) give us the same output.\nall pure functions are deterministic\nnot all deterministic functions are pure.\nconst reverseWord = word => word.split(\"\").reverse().join('');\n\nreverseWord('halle')\n//'ellah'\n\nNo side effects\n-doesnt mutate passed values\n-doesnt change varibles defined outside function\n-doesnt change application state\n\nconst addToOrder = (order, product) => {order.items.push(product)}\n//this not not a pure function becuase it modifies items property of orders.\n\nNative Methods\n[].splice = impure\n[].slice=pure ->returns new array\n[].push() = impure, remember that it returns the length of the new array....not very useful\n[].concat() = pure bc it returns a new array\n[].sort() =impure  bc it changes prexisiting array \n[].reverse() = impure bc changes the original array\n\nmaking copies of complex data \n\t\tarrays\n\t\tconst fruits = ['watermelon', 'kiwi', 'avacado', 'mango']\n\t\tconst copy = fruits.slice();\n\t\tconst copy = [].concat(fruits);\n\t\tconst copy =Array.from(fruits);\n\t\tconst copy = [...fruits];\n\t\t\nIf possible, try and use as many pure functions as possible....impure functions are useful for:\nclick handlers(registers a click)\nNetwork Calls - in order to change state....\nfile access - \n-DOM Management ","id":"9523ae5b-32a1-445b-a7f8-577206a75bbf","date":"2018-08-14T00:14:12.212Z"}